load("http://garsia.math.yorku.ca/~zabrocki/superpartitions.py")
def add_horizonal_border_strip(self, h):
    '''
    this function returns locations of the circles after they are shifted by ``h``
    input:
        self : a circled diagram e.g. [[4,1,0],[2]] ;
    variables:
        h: an integer representing number of cells added
        sp : the “uncircled diagram” e.g. self: .[[4,1,0],[2]] ; sp:[4,2,1,0]
        circle_location: a list indicating locations of circles. e.g. circle_location=[(1,4),(2,1)] ; meaning there is a circle at (1,4) and one at (2,1)
        rows with circle: a list of rows that have circles e.g. row_with_circle=[4,2,0] which means there’re three circles located at row4, row2 and row0.
        nsp1:a list of all partitions of size h and larger that differ by a horizontal border strip; notice that this list  does not take “insert values” as regular list does; when doing "nsp1[0].insert(0,0)” sage returns AttributeError: 'Partitions_all_with_category.element_class' object has no attribute 'insert'
        nsp: a copy of nsp1 in a regular list
    output:
        a list of circled diagrams e.g.[[2, 1, 0; 5, 2],
                                        [4, 1, 0; 3, 2],
                                        [2, 1, 0; 7],
                                        [4, 1, 0; 4, 1],
                                        [4, 1, 0; 5],
                                        [3, 1, 0; 6],
                                        [3, 1, 0; 5, 1],
                                        [2, 1, 0; 6, 1]]
    '''
    self = SuperPartition(self).to_circled_diagram()
    sp=self[0][:]
    sp.append(0)
    circle_location={}
    rows_with_circle=[]
    for i in range(len(self[1])):
        rows_with_circle.append(self[1][i][0]) ##to generate a list indicating which rows have circles                                         
    nsp1=Partition(sp).add_horizontal_border_strip(h) ##notice that the list generated by this function does not take “insert” as regular list does
    nsp=[]  
    for i in range(len(nsp1)):
        nsp.append([])
        for j in range(len(nsp1[i])):
            nsp[i].append(nsp1[i][j])##converting nsp1 to a regular list
        nsp[i].insert(len(nsp[i]),0)#adding zeros to reserve a possible extra row (as circle might be moved to a brand new row)
    for x in range(len(nsp)):
        circle_location[str(nsp[x])]=shift_circle_cells(self,nsp[x])
    legal_circle_location=circle_location
    for k in circle_location.values():
        for i in range(len(k)):
            for j in range(len(k)-1):
                if i!=j:
                    if k[i][0] == k[j][0] or k[i][1]==k[j][1]:
                        del(legal_circle_location[legal_circle_location.keys()[legal_circle_location.values().index(k)]])
    circle_diagram = convert_form(legal_circle_location)
    l=[]
    for i in range(len(circle_diagram)):
        l.append( SuperPartition.from_circled_diagram(circle_diagram[i][0],circle_diagram[i][1]))
    return l

def convert_form(legal_circle_location):
    '''
    input: -- dictionary { addable_diagram : circle location}
    {'[5, 2, 2, 1, 0]': [[1, 2], [3, 1], [4, 0]],
    '[4, 3, 2, 1, 0]': [[0, 4], [3, 1], [4, 0]],
    '[7, 2, 1, 0]': [[1, 2], [2, 1], [3, 0]],
    '[4, 4, 1, 1, 0]': [[0, 4], [2, 1], [4, 0]],
    '[5, 4, 1, 0]': [[1, 4], [2, 1], [3, 0]],
    '[6, 3, 1, 0]': [[1, 3], [2, 1], [3, 0]],
    '[5, 3, 1, 1, 0]': [[1, 3], [2, 1], [4, 0]],
    '[6, 2, 1, 1, 0]': [[1, 2], [2, 1], [4, 0]]}
  
    output: -- list[removable circle_diagram, circle location]
    [[[5, 3, 2, 2, 1], [[1, 2], [3, 1], [4, 0]]],
    [[5, 3, 2, 2, 1], [[0, 4], [3, 1], [4, 0]]],
    [[7, 3, 2, 1], [[1, 2], [2, 1], [3, 0]]],
    [[5, 4, 2, 1, 1], [[0, 4], [2, 1], [4, 0]]],
    [[5, 5, 2, 1], [[1, 4], [2, 1], [3, 0]]],
    [[6, 4, 2, 1], [[1, 3], [2, 1], [3, 0]]],
    [[5, 4, 2, 1, 1], [[1, 3], [2, 1], [4, 0]]],
    [[6, 3, 2, 1, 1], [[1, 2], [2, 1], [4, 0]]]]
    '''
    i=0
    cell_diagram=[[] for x in range(len(legal_circle_location))]
    circle_location = [[]for x in range(len(legal_circle_location))]
    circle_diagram=[[]for x in range(len(legal_circle_location))]
    for k ,v in legal_circle_location.items():
        cell_diagram[i] = ast.literal_eval(k)
        circle_location[i] = v
        i+=1
    for i in range(len(cell_diagram)):
        for j in range(len(circle_location[i])):
            k =circle_location[i][j][0]
            cell_diagram[i][k]=cell_diagram[i][k]+1
        circle_diagram[i].append(cell_diagram[i])
        circle_diagram[i].insert(1,circle_location[i])
    return circle_diagram

def shift_circle_cells(self,nsp):
    '''
    returns locations of circles that are bumped.
    input:
        self: a list ( circled diagram e.g. [[5,2,2,1], [(0,4),(2,1),(3,0)]] );
        nsp: a list (partition after adding cells e.g. [8, 2, 2, 1])
    output:
        list e.g. [[0, 4], [3, 1], [4, 0]]
    variables:
        sp : the “uncircled diagram” e.g. self: [[5,2,2,1], [(0,4),(2,1),(3,0)]] ; sp:[5,2,2,1]
        circle_location: a list indicating locations of circles. e.g. circle_location=[(1,4),(2,1)] ; meaning there is a circle at (1,4) and one at (2,1)
        rows with circle: a list of rows that have circles e.g. row_with_circle=[4,2,0] which means there’re three circles located at row4, row2 and row0.

    example:
        sage: shift_circle_cells([[5,2,2,1], [(0,4),(2,1),(3,0)]],[4, 3, 2, 1, 0])
        [[0, 4], [3, 1], [4, 0]]
    '''
    sp=self[0][:]
    sp.append(0)
    circle_location=[]
    rows_with_circle=[]
    for i in range(len(self[1])):             
        rows_with_circle.append(self[1][i][0]) ##to generate a list indicating which rows have circles                                         
    index=0
    k=0
    for i in rows_with_circle:
        if i < len(nsp)-1:
            if sp[i]!=nsp[i]: ###check if there’s a cell added to rows that have circle               
                j=rows_with_circle[k] ##j is the row where circle is located
                circle_location.append([j+1,nsp[i+1]]) ##adding moved circle location
            else:
                circle_location.append(list(self[1][index])) ##adding locations for the circles that did not move
            index+=1
        if i == len(nsp)-1:     ##special case where the circle is at the last row
            if sp[i]!=nsp[i]:   ##check if there’s a cell added to rows that have circle
                j=rows_with_circle[k]
                circle_location.append([j+1,0])  
                # if cells are added to the last row and the last row happen to have a 
                # circle, we have to append a new row to our diagram and put the circle there
            else:
                j=rows_with_circle[k]      
                circle_location.append(list(self[1][index]))
            index+=1
        k+=1
    return circle_location
